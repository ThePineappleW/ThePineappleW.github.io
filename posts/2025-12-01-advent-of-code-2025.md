---
title: Advent of Code 2025 Solutions
---

[Advent of Code](https://adventofcode.com) is an annual programming challenge in the month of December.
I highly recommend you check it out---the puzzles tend to be very creative and well-designed.
This year, there are 12 daily puzzles.

I'll be updating this blog post with my solutions for each of the puzzles.  
**There will be spoilers**.  
Please do not look at this page until you have made an honest effort to complete the puzzles yourself.

My implementations for this and prior years are available on [GitHub](https://github.com/ThePineappleW/AdventOfCode).

One final note: My solutions are not guaranteed to be optimal, efficient, or even a little bit clever.
I enjoy AOC because it helps me improve as a programmer. If you think any of my implementations could be improved, please let me know.

Now onto the puzzles.

<br>
<br>
<br>

# Day 1

[Puzzle link](https://adventofcode.com/2025/day/1)

### Python

This puzzle requires us to track the state of a circular dial with numbers `0`-`99`.
Since we want to represent the physical state of an object, let's make a class.
A `Dial` will simply store current value of the dial.

```python
class Dial:
  def __init__(self):
    self.val = 50 # The starting position
```

We can then add methods to represent turning the dial left and right.
I think it is preferable to have each method turn the dial exactly one position in the appropriate direction.
This makes the roll-over (`99 <-> 0`) in each direction very obvious,
and we can process any instruction by repeatedly calling one of these two methods.

```python
class Dial:
  def __init__(self):
    self.val = 50

  def left(self) -> None:
    self.val = self.val - 1 if self.val else 99

  def right(self) -> None:
    self.val = self.val + 1 if self.val < 99 else 0

  def turn(self, instr: str) -> None:
    direction = instr[0]
    amount = int(instr[1:])

    for _ in range(amount):
      if direction == 'L':
        self.left()
      else:
        self.right()
```

For Part 1 of the problem, we need to count the number of times the dial is at `0` after processing an instruction.
First, we'll add a field to the class, `zeros`, which tracks this count.
Since each call of `turn` corresponds to one instruction, we just need to update `zeros` after exiting the loop.

```python
def turn(self, instr: str) -> None:
  direction = instr[0]
  amount = int(instr[1:])

  for _ in range(amount):
    if direction == 'L':
      self.left()
    else:
      self.right()

  if self.val == 0:
    self.zeros += 1
```

Solving Part 1 is thus very simple. We instantiate a new `Dial`, and loop through the instructions:

```python
def count_zeros(instrs: Iterable[str]) -> int:
  d = Dial()
  for instr in instrs:
    d.turn(instr)
  return d.zeros
```

The twist in Part 2 is that we need to count _every time_ the dial reaches or passes over `0`.
The decision to decompose each instruction into a series of individual rotations makes this really easy.
In fact, we just need to move the value check in `turn` _inside_ the loop.

```python
def turn(self, instr: str) -> None:
  direction = instr[0]
  amount = int(instr[1:])

  for _ in range(amount):
    if direction == 'L':
      self.left()
    else:
      self.right()

->  if self.val == 0:
->    self.zeros += 1
```

That's it!
