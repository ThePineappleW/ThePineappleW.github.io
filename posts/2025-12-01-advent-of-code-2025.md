---
title: Advent of Code 2025 Solutions
---

[Advent of Code](https://adventofcode.com) is an annual programming challenge in the month of December.
I highly recommend you check it out---the puzzles tend to be very creative and well-designed.
This year, there are 12 daily puzzles.

I'll be updating this blog post with my solutions for each of the puzzles.  
**There will be spoilers**.  
Please do not look at this page until you have made an honest effort to complete the puzzles yourself.

My implementations for this and prior years are available on [GitHub](https://github.com/ThePineappleW/AdventOfCode).

One final note: My solutions are not guaranteed to be optimal, efficient, or even a little bit clever.
I enjoy AOC because it helps me improve as a programmer. If you think any of my implementations could be improved, please let me know.

Now onto the puzzles.

<br>
<br>
<br>

# Day 1

[Puzzle link](https://adventofcode.com/2025/day/1)

### Python

This puzzle requires us to track the state of a circular dial with numbers `0`-`99`.
Since we want to represent the physical state of an object, let's make a class.
A `Dial` will simply store current value of the dial.

```python
class Dial:
  def __init__(self):
    self.val = 50 # The starting position
```

We can then add methods to represent turning the dial left and right.
I think it is preferable to have each method turn the dial exactly one position in the appropriate direction.
This makes the roll-over (`99 <-> 0`) in each direction very obvious,
and we can process any instruction by repeatedly calling one of these two methods.

```python
class Dial:
  def __init__(self):
    self.val = 50

  def left(self) -> None:
    self.val = self.val - 1 if self.val else 99

  def right(self) -> None:
    self.val = self.val + 1 if self.val < 99 else 0

  def turn(self, instr: str) -> None:
    direction = instr[0]
    amount = int(instr[1:])

    for _ in range(amount):
      if direction == 'L':
        self.left()
      else:
        self.right()
```

For Part 1 of the problem, we need to count the number of times the dial is at `0` after processing an instruction.
First, we'll add a field to the class, `zeros`, which tracks this count.
Since each call of `turn` corresponds to one instruction, we just need to update `zeros` after exiting the loop.

```python
def turn(self, instr: str) -> None:
  direction = instr[0]
  amount = int(instr[1:])

  for _ in range(amount):
    if direction == 'L':
      self.left()
    else:
      self.right()

  if self.val == 0:
    self.zeros += 1
```

Solving Part 1 is thus very simple. We instantiate a new `Dial`, and loop through the instructions:

```python
def count_zeros(instrs: Iterable[str]) -> int:
  d = Dial()
  for instr in instrs:
    d.turn(instr)
  return d.zeros
```

The twist in Part 2 is that we need to count _every time_ the dial reaches or passes over `0`.
The decision to decompose each instruction into a series of individual rotations makes this really easy.
In fact, we just need to move the value check in `turn` _inside_ the loop.

```python
def turn(self, instr: str) -> None:
  direction = instr[0]
  amount = int(instr[1:])

  for _ in range(amount):
    if direction == 'L':
      self.left()
    else:
      self.right()

->  if self.val == 0:
->    self.zeros += 1
```

That's it!

<br>

# Day 2

[Puzzle link](https://adventofcode.com/2025/day/2)

### Python 

This puzzle involves discerning "invalid" numbers from a list of integer ranges.
For Part 1, a number is "invalid" if it consists of some sequence of digits repeated twice.

So, for arbitrary digits `A` and `B`, the numbers `AA`, `ABAB`, `ABAABA`, etc. are invalid.

Since we're concerned with the structure of digits in a string, this immediately strikes me as a regular expression problem.
I'm sure there's an efficient mathematical way to determine if a number fits the criterion,
but regular expressions are much closer to natural language, and are thus easier to implement.

Here's the regex we need:

```
^(\d+)\1$
```

Let's break it down.

- `^`: Anchor to the beginning of the string

- `(\d+)`: Match one or more numerical digits (`\d` is the same as `[0-9]`).
We create a _capturing group_ by wrapping this subexpression in parentheses.
This is basically a note to the regex engine to keep track of whatever was matched here, so we can refer to it later.

- `\1`: A _backreference_ to the first (and only) capturing group we defined.
This will evaluate to the value matched by the preceding `(\d+)`.

- `$`: Anchor to the end of the string.

Putting all those together, we represent a string which consists entirely of
a sequence of one or more digits, followed by that same sequence again.

All we need are a few helper functions. First we'll parse the input.

```python
def parse_input(s: str) -> list[list[int]]:
  return [[int(n) for n in rng.split("-")] for rng in s.split(",")]
```

Then, we'll filter out all of the valid numbers, and add up everything left.

```python
double_pattern = re.compile(r"^(\d+)\1$")

def add_invalid_in_range(start: int, end: int, pattern: re.Pattern) -> int:
  return sum(i for i in range(start, end + 1) if re.match(pattern, str(i)))
```
 
There are two things to note. First, make sure to use `re.compile` to pre-compile the regex.
All of the functions in Python's `re` module can consume regular expressions
in either the form of a `str` or an `re.Pattern`. In the former case, it will automatically compile the regex.
Since we'll be using the same regex a lot of times in a loop, we don't Python to have to parse it into an identical `Pattern` every single time.

Second, we use `re.match` to check if our string fits the pattern.
Python has a handful of similarly-named functions, and it's important to use the right one.
`re.match` will be truthy if the given string _starts with_ a sequence that matches the pattern.
It's OK to use it here because the regex pattern is anchored to the beginning and end of the string.
If you didn't include the `^...$` anchors, you would need to use `re.fullmatch` instead.

The documentation includes a [writeup](https://docs.python.org/3/library/re.html#search-vs-match) explaining the difference between these functions and `re.search`.

Finally, we just need to call `add_invalid_in_range` on every single range.

```python
def sum_invalid(s: str, pattern: re.Pattern) -> int:
  return sum(add_invalid_in_range(*rng, pattern) for rng in parse_input(s))
```

This is the solution to Part 1! Regex lets us solve it with three one-liners and a pattern.

Part 2 requires us to expand the criterion for invalid items.
Now, a number is invalid if it consists of two _or more_ repetitions of a sequence of digits.

This is trivial to implement, because regular expressions are so great at this kind of quantifications.
In fact, we just need to add a single character to the original pattern:

```
^(\d+)\1+$
        ^
```

The `+` quantifier means we'll match _one or more_ extra instances of the original sequence. Voil√†.

As a final note, this solution is not particularly efficient. Regex is slow.
But it is a very powerful tool for reasoning about the structure of text, and for converting high-level descriptions into actionable programs.
