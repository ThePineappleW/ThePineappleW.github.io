<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Emery Jacobowitz - Advent of Code 2025 Solutions</title>
    <link rel="stylesheet" href="../css/default.css" />
    <link rel="stylesheet" href="../css/syntax.css" />
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@4/tex-mml-chtml.js"></script>
    <script>
      // Triple-click to highlight code blocks. Stolen from Eric Wastl (adventofcode.com).
      window.addEventListener("click", function (e, s, r) {
        if (e.detail === 3) {
          const codeElement = e.target.closest("pre");
          console.log(e.target);
          console.log(codeElement);
          console.log("\n");
          if (codeElement) {
            s = window.getSelection();
            s.removeAllRanges();
            r = document.createRange();
            r.selectNodeContents(codeElement);
            s.addRange(r);
          }
        }
      });
    </script>
    <link rel="shortcut icon" href="favicon.ico" type="image/x-icon"><link rel="shortcut icon" href="../images/favicons/favicon32.png"><link rel="apple-touch-icon-precomposed" sizes="144x144" href="../images/favicons/favicon144.png"><link rel="apple-touch-icon-precomposed" sizes="114x114" href="../images/favicons/favicon114.png"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="../images/favicons/favicon72.png"><link rel="apple-touch-icon-precomposed" sizes="57x57" href="../images/favicons/favicon57.png">
  </head>
  <body>
    <header>
      <div class="logo">
        <a href="../">Emery Jacobowitz</a>
      </div>
      <nav>
        <a href="../">Home</a>
        <a href="../blog.html">Blog</a>
        <a href="../about.html">About</a>
      </nav>
    </header>

    <main role="main"><article>
    <section class="header">
        <h1>Advent of Code 2025 Solutions</h1>
        December  1, 2025
        
    </section>
    <section>
        <p><a href="https://adventofcode.com">Advent of Code</a> is an annual programming challenge in the month of December.
I highly recommend you check it out—the puzzles tend to be very creative and well-designed.
This year, there are 12 daily puzzles.</p>
<p>I’ll be updating this blog post with my solutions for each of the puzzles.<br />
<strong>There will be spoilers</strong>.<br />
Please do not look at this page until you have made an honest effort to complete the puzzles yourself.</p>
<p>My implementations for this and prior years are available on <a href="https://github.com/ThePineappleW/AdventOfCode">GitHub</a>.</p>
<p>One final note: My solutions are not guaranteed to be optimal, efficient, or even a little bit clever.
I enjoy AOC because it helps me improve as a programmer. If you think any of my implementations could be improved, please let me know.</p>
<p>Now onto the puzzles.</p>
<p><br>
<br>
<br></p>
<section id="day-1" class="level1">
<h1>Day 1</h1>
<p><a href="https://adventofcode.com/2025/day/1">Puzzle link</a></p>
<section id="python" class="level3">
<h3>Python</h3>
<p>This puzzle requires us to track the state of a circular dial with numbers <code>0</code>-<code>99</code>.
Since we want to represent the physical state of an object, let’s make a class.
A <code>Dial</code> will simply store current value of the dial.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dial:</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.val <span class="op">=</span> <span class="dv">50</span> <span class="co"># The starting position</span></span></code></pre></div>
<p>We can then add methods to represent turning the dial left and right.
I think it is preferable to have each method turn the dial exactly one position in the appropriate direction.
This makes the roll-over (<code>99 &lt;-&gt; 0</code>) in each direction very obvious,
and we can process any instruction by repeatedly calling one of these two methods.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> Dial:</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>):</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.val <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> left(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.val <span class="op">=</span> <span class="va">self</span>.val <span class="op">-</span> <span class="dv">1</span> <span class="cf">if</span> <span class="va">self</span>.val <span class="cf">else</span> <span class="dv">99</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> right(<span class="va">self</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.val <span class="op">=</span> <span class="va">self</span>.val <span class="op">+</span> <span class="dv">1</span> <span class="cf">if</span> <span class="va">self</span>.val <span class="op">&lt;</span> <span class="dv">99</span> <span class="cf">else</span> <span class="dv">0</span></span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> turn(<span class="va">self</span>, instr: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a>    direction <span class="op">=</span> instr[<span class="dv">0</span>]</span>
<span id="cb2-13"><a href="#cb2-13" aria-hidden="true" tabindex="-1"></a>    amount <span class="op">=</span> <span class="bu">int</span>(instr[<span class="dv">1</span>:])</span>
<span id="cb2-14"><a href="#cb2-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-15"><a href="#cb2-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(amount):</span>
<span id="cb2-16"><a href="#cb2-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> direction <span class="op">==</span> <span class="st">'L'</span>:</span>
<span id="cb2-17"><a href="#cb2-17" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.left()</span>
<span id="cb2-18"><a href="#cb2-18" aria-hidden="true" tabindex="-1"></a>      <span class="cf">else</span>:</span>
<span id="cb2-19"><a href="#cb2-19" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.right()</span></code></pre></div>
<p>For Part 1 of the problem, we need to count the number of times the dial is at <code>0</code> after processing an instruction.
First, we’ll add a field to the class, <code>zeros</code>, which tracks this count.
Since each call of <code>turn</code> corresponds to one instruction, we just need to update <code>zeros</code> after exiting the loop.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> turn(<span class="va">self</span>, instr: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>  direction <span class="op">=</span> instr[<span class="dv">0</span>]</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a>  amount <span class="op">=</span> <span class="bu">int</span>(instr[<span class="dv">1</span>:])</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(amount):</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> direction <span class="op">==</span> <span class="st">'L'</span>:</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.left()</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.right()</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="va">self</span>.val <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.zeros <span class="op">+=</span> <span class="dv">1</span></span></code></pre></div>
<p>Solving Part 1 is thus very simple. We instantiate a new <code>Dial</code>, and loop through the instructions:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> count_zeros(instrs: Iterable[<span class="bu">str</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  d <span class="op">=</span> Dial()</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> instr <span class="kw">in</span> instrs:</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    d.turn(instr)</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> d.zeros</span></code></pre></div>
<p>The twist in Part 2 is that we need to count <em>every time</em> the dial reaches or passes over <code>0</code>.
The decision to decompose each instruction into a series of individual rotations makes this really easy.
In fact, we just need to move the value check in <code>turn</code> <em>inside</em> the loop.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> turn(<span class="va">self</span>, instr: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="va">None</span>:</span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a>  direction <span class="op">=</span> instr[<span class="dv">0</span>]</span>
<span id="cb5-3"><a href="#cb5-3" aria-hidden="true" tabindex="-1"></a>  amount <span class="op">=</span> <span class="bu">int</span>(instr[<span class="dv">1</span>:])</span>
<span id="cb5-4"><a href="#cb5-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-5"><a href="#cb5-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> _ <span class="kw">in</span> <span class="bu">range</span>(amount):</span>
<span id="cb5-6"><a href="#cb5-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> direction <span class="op">==</span> <span class="st">'L'</span>:</span>
<span id="cb5-7"><a href="#cb5-7" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.left()</span>
<span id="cb5-8"><a href="#cb5-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb5-9"><a href="#cb5-9" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>.right()</span>
<span id="cb5-10"><a href="#cb5-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb5-11"><a href="#cb5-11" aria-hidden="true" tabindex="-1"></a><span class="op">-&gt;</span>  <span class="cf">if</span> <span class="va">self</span>.val <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb5-12"><a href="#cb5-12" aria-hidden="true" tabindex="-1"></a><span class="op">-&gt;</span>    <span class="va">self</span>.zeros <span class="op">+=</span> <span class="dv">1</span></span></code></pre></div>
<p>That’s it!</p>
<p><br></p>
</section>
</section>
<section id="day-2" class="level1">
<h1>Day 2</h1>
<p><a href="https://adventofcode.com/2025/day/2">Puzzle link</a></p>
<section id="python-1" class="level3">
<h3>Python</h3>
<p>This puzzle involves discerning “invalid” numbers from a list of integer ranges.
For Part 1, a number is “invalid” if it consists of some sequence of digits repeated twice.</p>
<p>So, for arbitrary digits <code>A</code> and <code>B</code>, the numbers <code>AA</code>, <code>ABAB</code>, <code>ABAABA</code>, etc. are invalid.</p>
<p>Since we’re concerned with the structure of digits in a string, this immediately strikes me as a regular expression problem.
I’m sure there’s an efficient mathematical way to determine if a number fits the criterion,
but regular expressions are much closer to natural language, and are thus easier to implement.</p>
<p>Here’s the regex we need:</p>
<pre><code>^(\d+)\1$</code></pre>
<p>Let’s break it down.</p>
<ul>
<li><p><code>^</code>: Anchor to the beginning of the string</p></li>
<li><p><code>(\d+)</code>: Match one or more numerical digits (<code>\d</code> is the same as <code>[0-9]</code>).
We create a <em>capturing group</em> by wrapping this subexpression in parentheses.
This is basically a note to the regex engine to keep track of whatever was matched here, so we can refer to it later.</p></li>
<li><p><code>\1</code>: A <em>backreference</em> to the first (and only) capturing group we defined.
This will evaluate to the value matched by the preceding <code>(\d+)</code>.</p></li>
<li><p><code>$</code>: Anchor to the end of the string.</p></li>
</ul>
<p>Putting all those together, we represent a string which consists entirely of
a sequence of one or more digits, followed by that same sequence again.</p>
<p>All we need are a few helper functions. First we’ll parse the input.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_input(s: <span class="bu">str</span>) <span class="op">-&gt;</span> <span class="bu">list</span>[<span class="bu">list</span>[<span class="bu">int</span>]]:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> [[<span class="bu">int</span>(n) <span class="cf">for</span> n <span class="kw">in</span> rng.split(<span class="st">&quot;-&quot;</span>)] <span class="cf">for</span> rng <span class="kw">in</span> s.split(<span class="st">&quot;,&quot;</span>)]</span></code></pre></div>
<p>Then, we’ll filter out all of the valid numbers, and add up everything left.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>double_pattern <span class="op">=</span> re.<span class="bu">compile</span>(<span class="vs">r&quot;</span><span class="dv">^</span><span class="kw">(</span><span class="dv">\d</span><span class="op">+</span><span class="kw">)</span><span class="ch">\1</span><span class="dv">$</span><span class="vs">&quot;</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> add_invalid_in_range(start: <span class="bu">int</span>, end: <span class="bu">int</span>, pattern: re.Pattern) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">sum</span>(i <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(start, end <span class="op">+</span> <span class="dv">1</span>) <span class="cf">if</span> re.match(pattern, <span class="bu">str</span>(i)))</span></code></pre></div>
<p>Note that we use <code>re.match</code> to check if our string fits the pattern.
Python has a handful of similarly-named functions, and it’s important to use the right one.
<code>re.match</code> will be truthy if the given string <em>starts with</em> a sequence that matches the pattern.
It’s OK to use it here because the regex pattern is anchored to the beginning and end of the string.
If you didn’t include the <code>^...$</code> anchors, you would need to use <code>re.fullmatch</code> instead.</p>
<p>The documentation includes a <a href="https://docs.python.org/3/library/re.html#search-vs-match">writeup</a> explaining the difference between these functions and <code>re.search</code>.</p>
<p>Finally, we just need to call <code>add_invalid_in_range</code> on every single range.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_invalid(s: <span class="bu">str</span>, pattern: re.Pattern) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">sum</span>(add_invalid_in_range(<span class="op">*</span>rng, pattern) <span class="cf">for</span> rng <span class="kw">in</span> parse_input(s))</span></code></pre></div>
<p>This is the solution to Part 1! Regex lets us solve it with three one-liners and a pattern.</p>
<p>Part 2 requires us to expand the criterion for invalid items.
Now, a number is invalid if it consists of two <em>or more</em> repetitions of a sequence of digits.</p>
<p>This is trivial to implement, because regular expressions are so great at this kind of quantifications.
In fact, we just need to add a single character to the original pattern:</p>
<pre><code>^(\d+)\1+$
        ^</code></pre>
<p>The <code>+</code> quantifier means we’ll match <em>one or more</em> extra instances of the original sequence. Voilà.</p>
<p>As a final note, this solution is not particularly efficient. Regex is slow.
But it is a very powerful tool for reasoning about the structure of text, and for converting high-level descriptions into actionable programs.</p>
<p><br>
<br></p>
</section>
</section>
<section id="day-3" class="level1">
<h1>Day 3</h1>
<p><a href="https://adventofcode.com/2025/day/3">Puzzle link</a></p>
</section>
<section id="python-2" class="level1">
<h1>Python</h1>
<p>Today’s puzzle is again digits-based. Given a string of digits, we have to find the maximum two-digit number than can be made by selecting digits left-to-right. The greatest number that can be made with the string <code>9582</code> is <code>98</code>, but the maximum of <code>8592</code> is 92.</p>
<p>The key observation is that we need to maximize the first digit. Once we do that, we can select the greatest value from all digits to the right of the first one we picked.</p>
<p>Finding the index of the greatest value in a list is a function called <a href="https://en.wikipedia.org/wiki/Arg_max"><code>argmax</code></a>, which is commonly used in machine learning. Here’s a Pythonic implementation thereof:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> argmax(lst: <span class="bu">list</span>[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">tuple</span>[<span class="bu">int</span>, <span class="bu">int</span>]:</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&quot;&quot;&quot;Returns the index and the value of the greatest element in the list.&quot;&quot;&quot;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">max</span>(<span class="bu">enumerate</span>(lst), key <span class="op">=</span> <span class="kw">lambda</span> x: x[<span class="dv">1</span>])</span></code></pre></div>
<p><code>enumerate(...)</code> returns a list of <code>(</code>index<code>,</code>value<code>)</code> tuples, within which we find the tuple that has the maximum value, and return it. Note that we’re returning both the index <em>and</em> the maximum value, because we’ll need both to solve the puzzle.</p>
<p>We can use <code>argmax</code> to find the greatest number to use as the tens digit. It is important that we do not search the entire list of values, because we will still need to find the ones digit. What if our input was something like <code>529</code>? The maximum value is <code>9</code>, but because this is the last value, it could only ever be the ones digit. Here’s my implementation of Part 1:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_two_digits(digits: <span class="bu">list</span>[<span class="bu">int</span>]) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>  idx, left <span class="op">=</span> argmax(digits[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a>  _, right <span class="op">=</span> argmax(digits[idx <span class="op">+</span> <span class="dv">1</span>:])</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>  result <span class="op">=</span> <span class="dv">10</span> <span class="op">*</span> left <span class="op">+</span> right</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> result</span></code></pre></div>
<p>The first line finds the left (tens) digit; note that it excludes the final value as explained above. Once the left digit has been found, the list is partitioned right after it. We take the argmax again to find the right (ones) digit, but this time only search the portion of the list <em>after</em> the index of the left digit.</p>
<p>Finally we just need a couple of helper functions to parse the input from text to lists of integers, and add up all the joltages:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> parse_file(f):</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&quot;&quot;&quot;Splits the input file into lists of integers.&quot;&quot;&quot;</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> line <span class="kw">in</span> f:</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">yield</span> [<span class="bu">int</span>(n) <span class="cf">for</span> n <span class="kw">in</span> line.strip()]</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sum_joltages(f, n:<span class="bu">int</span>, verbose<span class="op">=</span><span class="va">False</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">&quot;&quot;&quot;Finds the total joltage for a file-like containing battery levels.&quot;&quot;&quot;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">sum</span>(max_two_digits(digits) <span class="cf">for</span> digits <span class="kw">in</span> parse_file(f))</span></code></pre></div>
<p>That’s it for Part 1!</p>
<p>Part 2 predictably asks us to generalize from two-digit numbers. It specifically asks us for 12 digits, but we’ll implement a function that works for all numbers &gt;1.</p>
<p>This isn’t particularly difficult because we were already very close. The procedure for <code>max_two_digits</code> is just to call <code>argmax</code>, then shrink the list and call <code>argmax</code> again.
To generalize, we just have to make this a recursive function. Call <code>argmax</code>, then shrink the list and recur. There are a few tricky points to discuss, but here’s the generalized solution for Part 2:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> max_n_digits(digits: <span class="bu">list</span>[<span class="bu">int</span>], n: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>  <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">  Returns the greatest n-digit number  that can be constructed</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a><span class="co">  from the provided list of digits, left-to-right.</span></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a>  n_1 <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a>  right_bound <span class="op">=</span> <span class="op">-</span>n_1 <span class="kw">or</span> <span class="va">None</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a>  idx, digit <span class="op">=</span> argmax(digits[:right_bound])</span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> n <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> digit</span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> (digit <span class="op">*</span> <span class="dv">10</span> <span class="op">**</span> n_1) <span class="op">+</span> max_n_digits(digits[idx <span class="op">+</span> <span class="dv">1</span>:], n_1)</span></code></pre></div>
<p><code>right_bound</code> represents the indices to reserve from each search for the maximum digit. When we’re looking for the first of 12 digits, we know for certain that it won’t be within the last 11 (<code>n - 1</code>) values in the list. In the base case where <code>n</code> = <code>1</code>, we don’t want to exclude any values. Slicing a list at <code>[:-0]</code> will give us the empty list, so we need to ensure that the end index is <code>None</code> in this case.</p>
<p>The sum is built up by adding the maximum digit mulitplied by <span class="math inline">\(10^{n-1}\)</span>, which corresponds to the appropriate place-value.</p>
<p>A speedy and elegant solution for a somewhat simple puzzle. Because Advent of Code is only 12 days this year, I suspect the difficulty will start ramping up soon.</p>
</section>
    </section>
</article>
</main>

    <footer>
      Site proudly generated by
      <a href="http://jaspervdj.be/hakyll">Hakyll</a>
    </footer>
  </body>
  <script type="text/javascript" src="../js/interlinear.js"></script>
</html>
